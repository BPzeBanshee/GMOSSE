<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-99</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Creation Code Vars needed:
globalvar max_w,spd_x,spd_y,delay_x,delay_y;

max_w = the maximum horizontal width the player
        can traverse within the view
spd_x = the horizontal speed you want
spd_y = the vertical speed you want

Set these higher than 1 only for fractional values!
delay_x = the amount of frames to wait until
delay_y   the "speed" is applied
        
Place your values for those variables
in the Creation Code event of this
object in the room you want to use
it in. Do not modify anything else.
*/
if global.update exit;
event_user(0); // Loading of needed objects to scroll with view

// Update view (xview has additional wobblescroll formula)
if max_w &gt; 240 then w = max_w/(max_w-240) else w = max_w;
view_xview[0] = floor(x+((obj_ctrl_game.x - x)/w))-x_o;
view_yview[0] = floor(y)-y_o;
alarm[0] = delay_x;
alarm[1] = delay_y;
// GMS specific: force view to controller position first
//view_xview[0] = floor(x)-x_o;
//view_yview[0] = floor(y)-y_o;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical scrolling
if spd_y = 0 then exit;

for (i=0;i&lt;m_o;i++) with objects_to_scroll[i] y += spd_y;
y += spd_y;
alarm[1] = delay_y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal scrolling
if spd_x = 0 then exit;

for (i=0;i&lt;m_o;i++) with objects_to_scroll[i] x += spd_x;
x += spd_x;
alarm[0] = delay_x;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.update || instance_exists(obj_ctrl_clear) then exit;
    
// Update view (xview has additional wobblescroll formula) 
if instance_exists(obj_player)
then view_xview[0] = floor(x+((obj_hitbox.x - x)/w))-x_o
else if max_w &gt; 240
    {
    if xview &gt; floor(x+((max_w-240)/2)) then view_xview[0] -= 1;
    if xview &lt; floor(x+((max_w-240)/2)) then view_xview[0] += 1;
    }
view_yview[0] = floor(y)-y_o;

// update offset-adjusted view vars
scr_view_vars();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>objects_to_scroll[0] = obj_player;
objects_to_scroll[1] = obj_hitbox;
objects_to_scroll[2] = obj_afterimage;
objects_to_scroll[3] = obj_stock_bomb;
objects_to_scroll[4] = obj_en_trans;
objects_to_scroll[5] = obj_en_parent;
objects_to_scroll[6] = obj_bullettarget;
objects_to_scroll[7] = obj_popup;
objects_to_scroll[8] = obj_player_shot;

switch global.shipselect
    {
    case 1:
        {
        objects_to_scroll[9] = obj_xono_shothit;
        objects_to_scroll[10] = obj_xono_laser2;
        break;
        }
    case 2:
        {
        objects_to_scroll[9] = obj_warbird_shothit;
        objects_to_scroll[10] = obj_warbird_laser2;
        objects_to_scroll[11] = obj_warbird_volt;
        break;
        }
    case 3:
        {
        objects_to_scroll[9] = obj_bh_trace;
        objects_to_scroll[10] = obj_bh_traceorb;
        objects_to_scroll[11] = obj_bh_shothit;
        objects_to_scroll[12] = obj_bh_orb;
        break;
        }
    case 4:
        {
        objects_to_scroll[9] = obj_sf_shothit;
        break;
        }
    case 5:
        {
        objects_to_scroll[9] = obj_arxyne_shot2b;
        objects_to_scroll[10] = obj_arxyne_shot2c;
        break;
        }
    }
m_o = array_length_1d(objects_to_scroll);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
