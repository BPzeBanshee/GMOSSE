<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
obj_ctrl_render, by BPzeBanshee

At last, a modern render system that doesn't chew up a
stupid amount of performance in the process of handling surfaces!

This render system's end result is designed to be very similar to that
of Blue Revolver's video options: free control of the game scale and
rotation without GM's stupid view_angle glitches while looking pretty.
*/
// Define base resolution (modify event_user(0)'s smaller entries if changing this though)
m_base_w = 240;
m_base_h = 320;
window_set_min_width(m_base_w);
window_set_min_height(m_base_h);
application_surface_draw_enable(false);
surface_resize(application_surface,m_base_w,m_base_h);

// Define configurable variables
m_aspect = global.window_aspect;    // aspect ratio, 0=3:4 (native), 1=4:3, 2=16:9, 3=16:10
m_size = global.window_size;        // selector var for resolution list (see event_user(0))
m_angle = global.rotation;          // angle of screen in degrees
m_clean = global.scaling;           // proportional or clean scale
m_wallpaper = global.use_wallpaper; // draw wallpaper (off/1-5)?
m_scanlines = global.scanlines;     // scanlines (off/horizontal/vertical)
m_filter_bi = global.filter;        // interpolation of textures/bilinear filter (off/on)

// Define self-configured variables
l_firstrun = 0;
l_scale = 1;  // automatically calculated in step
l_delay = 12; // masks funny behaviour while changing window size
l_res = "";
l_wall_img[0] = bkg_wallpaper;
//l_wall_w = 1920;
//l_wall_h = 1080;
//l_wall_s = 1;
//l_wall_max_s = 1;
l_scan = -1;
l_scan_img = -1;
l_scan_scale = l_scale;
l_scan_a = global.scanline_alpha / 100;

// Define control aspect ratio settings for windowed mode
// 3:4
m_array_w[0,0] = 240; m_array_h[0,0] = 320;
m_array_w[0,1] = 480; m_array_h[0,1] = 640;
m_array_w[0,2] = 720; m_array_h[0,2] = 960;

// 4:3
m_array_w[1,0] = 640; m_array_h[1,0] = 480;
m_array_w[1,1] = 800; m_array_h[1,1] = 600;
m_array_w[1,2] = 1024; m_array_h[1,2] = 768;
m_array_w[1,3] = 1280; m_array_h[1,3] = 1024;

// 16:9
m_array_w[2,0] = 640; m_array_h[2,0] = 360;
m_array_w[2,1] = 720; m_array_h[2,1] = 405;
m_array_w[2,2] = 848; m_array_h[2,2] = 480;
m_array_w[2,3] = 960; m_array_h[2,3] = 540;
m_array_w[2,4] = 1024; m_array_h[2,4] = 576;
m_array_w[2,5] = 1280; m_array_h[2,5] = 720;
m_array_w[2,6] = 1366; m_array_h[2,6] = 768;
m_array_w[2,7] = 1600; m_array_h[2,7] = 900;
m_array_w[2,8] = 1920; m_array_h[2,8] = 1080;
m_array_w[2,9] = 2560; m_array_h[2,9] = 1440;
m_array_w[2,10] = 3840; m_array_h[2,10] = 2160;

// 16:10
m_array_w[3,0] = 1280; m_array_h[3,0] = 800;
m_array_w[3,1] = 1440; m_array_h[3,1] = 900;
m_array_w[3,2] = 1680; m_array_h[3,2] = 1050;
m_array_w[3,3] = 1920; m_array_h[3,3] = 1200;
m_array_w[3,4] = 2560; m_array_h[3,4] = 1600;

alarm[2] = 5;
alarm[0] = l_delay;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Window_set_size needs to wait a bit at the start
event_user(0); // set window size according to selected resolution
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Bilinear filtering
//texture_set_interpolation(global.filter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Call scr_screen_init AFTER window size is set
scr_screen_init();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if l_delay &gt; 0 then l_delay -= 1;

if (m_size != global.window_size 
or m_aspect != global.window_aspect)
&amp;&amp; l_delay = 0
then event_user(0);

// DEBUG COMMANDS
/*
// Adjust angle as needed (no more view_angle!)
if keyboard_check_pressed(ord("Q")) 
    {
    m_angle -= 90; if m_angle &lt; 0 then m_angle = 270;
    }
if keyboard_check_pressed(ord("E")) 
    {
    m_angle += 90; if m_angle &gt; 270 then m_angle = 0;
    }

// Set scaling to clean or proportional
if keyboard_check_pressed(ord("R")) then m_clean = !m_clean;

// Set window size according to aspect ratio size and update window
if keyboard_check_pressed(ord("T"))
    {
    m_size += 1;
    if m_size &gt; l_max_size then m_size = 0;
    event_user(0);
    }
    
// Set aspect ratio and update window
if keyboard_check_pressed(ord("Y"))
    {
    m_aspect += 1;
    if m_aspect &gt; 3 then m_aspect = 0;
    event_user(0);
    }
    
// Toggle Wallpaper
if keyboard_check_pressed(ord("U")) then m_wallpaper = !m_wallpaper;
*/

/// Update options
m_angle = global.rotation;
m_clean = global.scaling;
m_wallpaper = global.use_wallpaper;
if m_filter_bi != global.filter
    {
    m_filter_bi = global.filter;
    alarm[1] = 1;
    }

// Adjust scale as needed (no more viewports, hooray!)
if m_angle = 90 || m_angle = 270
then l_scale = min(window_get_width()/m_base_h,window_get_height()/m_base_w)
else l_scale = min(window_get_width()/m_base_w,window_get_height()/m_base_h);
if m_clean then l_scale = max(1,floor(l_scale));

if m_scanlines != global.scanlines
|| l_scan_scale != l_scale
then event_user(1);

// Offset x/y for centering the drawn surface
x = round(window_get_width()/2);
y = round(window_get_height()/2);
xx = x - lengthdir_x((m_base_w/2)*l_scale,m_angle) - lengthdir_x((m_base_h/2)*l_scale,m_angle+270);
yy = y - lengthdir_y((m_base_w/2)*l_scale,m_angle) - lengthdir_y((m_base_h/2)*l_scale,m_angle+270);

// Update wallpaper draw scale if necessary
/*var w,h; w = window_get_width(); h = window_get_height();
l_wall_x = (w - l_wall_w)/2;
l_wall_y = 0;
if w &gt; h 
    {
    l_wall_s = (w/l_wall_w);
    //l_wall_s = l_wall_w / l_wall_max_s;
    } 
else 
    {
    l_wall_s = (h/l_wall_h);
    //l_wall_s = l_wall_h / l_wall_max_s;
    }
//show_message(string(l_wall_x)+", "+string(l_wall_y))
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Generating scanlines
if !window_has_focus()
    {
    /*show_debug_message("event_user(1) called while focus lost, l_scan_scale: "
    +string(l_scan_scale)
    +", l_scale: "+string(l_scan_scale)
    +", application surface size at: "+string(surface_get_width(application_surface))
    +"x"+string(surface_get_height(application_surface)));*/
    exit;
    }
    
var w,h,s,sw,sh; 
// Get surface values
w = surface_get_width(application_surface)*l_scale; 
h = surface_get_height(application_surface)*l_scale;

// Decide what kind of scanline to use
m_scanlines = global.scanlines;
l_scan_scale = l_scale; // for changing from clean to stretch
switch m_scanlines
    {
    default: s = -1; break;
    case 1: s = spr_scanline_hori; break;
    case 2: s = spr_scanline_vert; break;
    case 3: s = spr_static; break;
    }
sw = sprite_get_width(s);
sh = sprite_get_height(s);
si = 0;

// Create surface
if surface_exists(l_scan)
    {
    if surface_get_width(l_scan) != w || surface_get_height(l_scan) != h
    then surface_resize(l_scan,w,h);
    }
else l_scan = surface_create(w,h);

// Draw scanlines onto surface
surface_set_target(l_scan);
draw_clear_alpha(c_black,0);
draw_set_color(c_black);
draw_set_alpha(1);

if sprite_exists(s) 
then for (i=0;i&lt;w;i+=sw)
    {
    for (j=0;j&lt;h;j+=sh)
        {
        if m_scanlines = 3 then si = irandom_range(0,sprite_get_number(spr_static)-1);
        draw_sprite(s,si,i,j);
        }
    }

/*if m_scanlines = 1 then for(i=0;i&lt;h;i+=2) draw_line(-1,i,w,i); // Horizontal
if m_scanlines = 2 then for(i=0;i&lt;w;i+=2) draw_line(i,-1,i,h); // Vertical
if m_scanlines = 3 // Static drawing
    {
    for (i=0;i&lt;w;i+=sprite_get_width(spr_static))
        {
        for (j=0;j&lt;h;j+=sprite_get_height(spr_static))
            {
            draw_sprite(spr_static,irandom_range(0,sprite_get_number(spr_static)-1),i,j);
            }
        }
    }*/
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set Window size according to aspect etc
if !window_has_focus()
    {
    /*show_debug_message("event_user(0) called while focus lost, m_size: "
    +string(m_size)
    +", global.window_size: "+string(global.window_size)
    +", m_aspect: "+string(m_aspect)
    +", global.window_aspect: "+string(global.window_aspect));*/
    exit;
    }

// First, update the maximum array iteration size
m_aspect = global.window_aspect;
l_max_size = array_length_2d(m_array_w,m_aspect)-1;
if global.window_size &gt; l_max_size then global.window_size = l_max_size;

// Then check the maximum size for our current display, and bound global.window_size to it
if m_array_w[m_aspect,global.window_size] &gt; display_get_width() then
while m_array_w[m_aspect,global.window_size] &gt; display_get_width() global.window_size -= 1;
m_size = min(global.window_size,l_max_size);

// Then pluck the array variables and adjust window size accordingly
var w,h;
w = m_array_w[m_aspect,m_size];
h = m_array_h[m_aspect,m_size];
window_set_size(w,h);

if !l_firstrun 
    {
    // if we center in consecutive runs on Win7 we get garbage graphics
    // and if we just use window_center it's even worse
    var xx,yy,dw,dh;
    dw = display_get_width();
    dh = display_get_height();
    xx = (dw / 2) - (w / 2);
    yy = (dh / 2) - (h / 2);
    if window_get_x() != xx || window_get_y() != yy
    then window_set_position(xx,yy);
    l_firstrun = 1;
    }

l_res = string(w)+"x"+string(h);
if !window_get_fullscreen()
    {
    l_delay = 11;
    alarm[1] = 11;
    }
else alarm[1] = 2;

//show_debug_message("obj_ctrl_render: event user 0, w: "+string(w)+", h: "+string(h));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[1] = 1; // bilinear filter seems to reset on room change
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if l_delay &gt; 0 then exit;
draw_set_alpha(1);

if m_wallpaper &gt; 0
    {
    // TODO: Scale to aspect rather than squishing 1920x1080 images in 4:3 windows
    //draw_background_ext(l_wall_img[m_wallpaper-1],l_wall_x,l_wall_y,l_wall_s,l_wall_s,0,c_white,1);
    draw_background_stretched(l_wall_img[m_wallpaper-1],0,0,window_get_width(),window_get_height());
    draw_set_alpha(1 - min(0.9,global.wallbrightness/100));
    draw_sprite_stretched(spr_blackpixel,0,0,0,window_get_width(),window_get_height());
    draw_set_alpha(1);
    draw_sprite_ext(spr_outline,0,x,y,l_scale,l_scale,m_angle,c_white,1);
    }

if global.filter then texture_set_interpolation(true);
draw_set_blend_mode_ext(bm_one,bm_zero);
draw_surface_ext(application_surface,round(xx),round(yy),l_scale,l_scale,m_angle,c_white,1);
draw_set_blend_mode(bm_normal);
if global.filter then texture_set_interpolation(false);
//draw_set_blend_mode_ext(bm_src_alpha, bm_inv_src_alpha);

// Apply scanlines if necessary
if m_scanlines &gt; 0
    {
    if !surface_exists(l_scan)
    then event_user(1)
    else draw_surface_ext(l_scan,round(xx),round(yy),1,1,m_angle,c_white,global.scanline_alpha/100);
    }
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>globalvar xview,yview;
xview = view_xview[0];
yview = view_yview[0];
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
